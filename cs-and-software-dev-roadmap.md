# ☐ Software Development Roadmap

☑ make roadmap
## 0. Abbreviations
* CWD: Computing with Data (Lebanon & El-Geish, 2018)
* FoCS: Foundations of Computer Science (Aho & Ullman, 1994)
* SICP: Structure and Interpretation of Computer Programs
* CPTT: Compilers - Principles, Techniques, & Tools 2E (Aho et al., 2007)
* CS: Computing Systems (Elahi, 2018)
* Algorithms, Languages, Automata, and Compilers
* Linux Systems Programming
* Write Great Code 1
* Write Great Code 2
* Computer Systems - A Programmer's Perspective
* How Software Works
* Assembly Language Step-by-Step. Programming with Linux 
* Introduction to Digital Electronics
* The Art of Assembly Language Programming
* How to Design, Build and Program Your Own Working Computer System
* Digital Computer Electronics
* Computer Science Distilled
* Essentials of Programming Languages
* The C Programming Language, 2E
* Inside the Python Virtual Machine
* Inside the Java Virtual Machine
* Touch of Class
* The Healthy Programmer
* An Introduction to Formal Languages and Automata
* A Course in Formal Languages, Automata, and Groups (Chiswell)
* Introduction to the Theory of Formal Languages and Automata (Levelt)
* Intro to Automata Theory, Languages, and Computation (Hopcroft)
* The Annotated Turing
* Processor Microarchitecture
* Structured Computer Organization, 6E (Tanenbaum & Austin, 2013)
* C++ by Dissection
* Thinking in C++
* The C++ Programming Language
* Tour of C++
* Programming Principles and Prictice Using C++
* The Algorithm Design Manual
* Introduction to Algorithms
* First Course in Algorithms through Puzzles
* 


## X. Sort
☐ CwD 2. Essential Knowledge: Hardware
☐ CwD 3. Essential Knowledge: Operating Systems
☐ CwD 4. Learning C++
☐ CwD 5. Learning Java
☐ CwD 6. Learning Python and a Few More Things
☐ CwD 7. Learning R
☐ CwD 8. Visualizing Data in R and Python
☐ CwD 9. Processing Data in R and Python
☐ CwD 10. Essential Knowledge: Parallel Programming
☐ CwD 11. Essential Knowledge: Testing
☐ CwD 12. A Few More Things about Programming
☐ CwD 13. Essential Knowledge: Data Stores
☐ CwD 14. Thoughts on System Design for Big Data
☐ CwD 15. Thoughts on Software Craftsmanship

☐ FoCS 1. Computer Science: The Mechanization of Abstraction
☐ FoCS 2. Iteration, Induction, and Recursion
☐ FoCS 3. The Running Time of Programs
☐ FoCS 4. Combinatorics and Probability
☐ FoCS 5. The Tree Data Model
☐ FoCS 6. The List Data Model
☐ FoCS 7. The Set Data Model
☐ FoCS 8. The Relational Data Model
☐ FoCS 9. The Graph Data Model
☐ FoCS 10. Patterns, Automata, and Regular Expressions
☐ FoCS 11. Recursive Description Patterns
☐ FoCS 12. Propositional Logic
☐ FoCS 13. Using Logic to Design Computer Components
☐ FoCS 14. Predicate Logic

☐ SICP 1. Building Abstractions with Procedures 
☐ SICP 2. Building Abstractions with Data
☐ SICP 3. Modularity, Objects, and State
☐ SICP 4. Metalinguistic Abstraction
☐ SICP 5. Computing with Register Machines

☐ CPTT 1. Introduction
☐ CPTT 2. A Simple Syntax-Directed Translator
☐ CPTT 3. Lexical Analysis
☐ CPTT 4. Syntax Analysis
☐ CPTT 5. Syntax-Directed Translation
☐ CPTT 6. Intermediate-Code Generation
☐ CPTT 7. Run-Time Environments
☐ CPTT 8. Code Generation
☐ CPTT 9. Machine-Independent Optimizations
☐ CPTT 10. Instruction-Level Parallelism
☐ CPTT 11. Optimizing for Parallelism and Locality
☐ CPTT 12. Interprocedural Analysis
☐ CPTT A. Complete Front End
☐ CPTT B. Finding Linearly Independent Solutions

☐ CS 1. Signals and Number Systems
☐ CS 2. Boolean Logics and Logic Gates
☐ CS 3. Midterms, MAxterms, Karnaugh Map, and Universal Gates
☐ CS 4. Combinational Logic
☐ CS 5. Synchronous Sequential Logic
☐ CS 6. Introduction to Computer Architecture
☐ CS 7. Memory
☐ CS 8. Assembly Language and ARM Instructions Part I
☐ CS 9. ARM Instructions Part II
☐ CS 10. ARM Assembly Language Programming Using Keil Developing Tools

## ☐ 1. Essential Tools

### ☐ Shell Basics

### ☐ Vim

### ☐ Nano

### ☐ Emacs (Basics)

### ☐ Git

### ☐ 

### ☐ 

### ☐ 

### 
## ☐ 2. Solid Grasp of Key High-Level Languages

###  ☐ a) Python


### ☐ b) Java


### ☐ c) C


### ☐ d) C++


### ☐ e) JavaScript + HTML + CSS


### ☐ f) R

## ☐ 2. Important Tools

## ☐ 3. Low-Level Basics

### ☐ Code (Charles Petzold)
☐ Code 1. Best Friends
☐ Code 2. Codes and Combinations
☐ Code 3. Braille and Binary Codes
☐ Code 4. Anatomy of a Flashlight
☐ Code 5. Seeing around Corners
☐ Code 6. Telegraphs and Relays
☐ Code 7. Our Ten Digits
☐ Code 8. Alternatives to Ten
☐ Code 9. Bit by Bit by Bit
☐ Code 10. Logic and Switches
☐ Code 11. Gates (Not Bill)
☐ Code 12. A Binary Adding Machine
☐ Code 13. But What about Subtraction?
☐ Code 14. Feedback and Flip-Flops
☐ Code 15. Bytes and Hex
☐ Code 16. An Assemblage of Memory
☐ Code 17. Automation
☐ Code 18. From Abaci to Chips
☐ Code 19. Two Classic Microprocessors
☐ Code 20. ASCII and a Cast of Characters
☐ Code 21. Get on the Bus
☐ Code 22. The Operating System
☐ Code 23. Fixed Point, Floating Point
☐ Code 24. Languages High and Low
☐ Code 25. The Graphical Revolution
☐

### ☐ Elements of Computing Systems
☐ EoCS 1. Boolean Logic
☐ EoCS 2. Boolean Arithmetic
☐ EoCS 3. Sequential Logic
☐ EoCS 4. Machine Language
☐ EoCS 5. Computer Architecture
☐ EoCS 6. Assembler
☐ EoCS 7. Virtual Machine I: Stack Arithmetic
☐ EoCS 8. Virtual Machine II: Program Control
☐ EoCS 9. High-Level Language
☐ EoCS 10. Compiler I: Syntax Analysis
☐ EoCS 11. Compiler II: Code Generation
☐ EoCS 12. Operating System
☐ EoCS 13. Postscript: More Fun to Go
☐ EoCS 14. Appendix A: HDL
☐ EoCS 15. Appendix B: Test Scripting Language

## 3. Basic Familiarity with Additional Languages

### a) Haskell


### b) Scala


### c) Rust


### d) Fortran


### e) Common Lisp


### f) Racket


### g) Scheme


### h) Perl


### i) Octave


## ☐ 4. Understanding of Software Package Structures



### Python


### C++


### Java


### Julia


### JavaScript


### Perl


### Other Languages


##  Reading and Writing Files


## Basic Mathematical Problem Solving


## 